/* Sid Parikh. Created on December 3, 2021, for Advent of Code */
package com.sidparikh.advent.solutions;

import com.sidparikh.advent.Solution;

import java.io.IOException;
import java.util.ArrayList;

/**
 * Day 3: Binary Diagnostic
 * <p>
 * We've got some strange creaking noises, so lets check the diagnostics. <br>
 * Star One: Take the diagnostic report and calculate the power consumption. <br>
 * Star Two: Take the diagnostic report and verify the life support rating.
 */
public class Day03 extends Solution {

    /**
     * LENGTH keeps track of the length of the rows in the input so I can easily switch between example input (5) and my
     * puzzle input (12).
     */
    private final int LENGTH ;

    public Day03() throws IOException {
        super(3);
        LENGTH = input.get(0).length();
    }

    /**
     * Calculates the life support rating, equal to the product of the gamma rate and epsilon rate.
     * <p>
     * The gamma rate is the number resulting from keeping the most common bit in each column/position, and the epsilon
     * rate is the number resulting from doing the same with the least common bit.
     *
     * @return the life support rating (1458194)
     */
    @Override
    public String partOne() {
        // Convert rows of binary numbers to a 2D array of 1s and 0s
        boolean[][] binary = new boolean[input.size()][LENGTH];
        for (int i = 0; i < input.size(); i++) {
            char[] temp = input.get(i).toCharArray();
            for (int j = 0; j < temp.length; j++) {
                binary[i][j] = (temp[j] == '1');
            }
        }
        // Count the number of ones in each column.
        int[] countOnes = new int[LENGTH];
        int[] epsilon = new int[LENGTH];
        for (boolean[] row : binary) {
            for (int j = 0; j < binary[0].length; j++) {
                if (row[j]) countOnes[j]++;
            }
        }
        // If there are more ones than half the number of rows, then 1 is the most common bit.
        // Save the most common bit in countOnes[] and save the opposite of that bit in epsilon[].
        // ie reuse countOnes to record the gamma rate.
        final int l = binary.length / 2;
        for (int i = 0; i < countOnes.length; i++) {
            if (countOnes[i] > l) {
                countOnes[i] = 1;
                epsilon[i] = 0;
            } else {
                countOnes[i] = 0;
                epsilon[i] = 1;
            }
        }

        // Convert the int[]s of 0s and 1s to actual numbers.
        StringBuilder sb = new StringBuilder();
        for (int c : countOnes) sb.append(c);

        StringBuilder sb2 = new StringBuilder();
        for (int c : epsilon) sb2.append(c);

        int delta = Integer.parseInt(sb.toString(), 2);
        int epsilonF = Integer.parseInt(sb2.toString(), 2);

        return String.valueOf((long) delta * epsilonF);

    }

    /**
     * Calculates the life support rating, equal to the product of the oxygen generator rating and the CO2 scrubber
     * rating.
     * <p>
     * The oxygen generator rating is generated by iterating through the columns/positions and only keeping entries that
     * match the most common bit in that column. Keep 1s in case of ties. The CO2 scrubber rating is the
     * opposite; keep the least common bit. In case of ties keep 0s.
     *
     * @return the life support rating (2829354)
     */
    @Override
    public String partTwo() {
        // Reusable temp
        int i;

        // Set up two identical lists of numbers so we can remove items dynamically and separately.
        ArrayList<Integer> oxy = new ArrayList<>();
        ArrayList<Integer> co2 = new ArrayList<>();
        for (String s : input) {
            int n = Integer.parseInt(s, 2);
            oxy.add(n);
            co2.add(n);
        }

        i = 0;
        // When the size of the list becomes one, we have found the oxygen generator rating.
        while (oxy.size() > 1 && i < LENGTH) {
            // Keep track of the number of 1s in a given position.
            int co = 0;
            // Bit-shift right by (LENGTH-1) - i to find the digit in the i-th position. Because bit-shifting is very
            // efficient, this should be better than the 2D array solution from part one, but that is just a guess.
            // (n & 1) returns the last digit of the binary representation of an integer n.
            for (int n : oxy) {
                if (((n >> (LENGTH - 1) - i) & 1) == 1) co++;
            }
            // Compare the number of ones to half the current size of the list.
            final double l = (double) oxy.size() / 2;
            // Need to copy i to a final int to use in a lambda.
            final int finalI = i;
            // Now that we've found the most common bit, we have to re-iterate to remove numbers that do not have this
            // bit in the i-th position. In case of tie, remove 0s.
            // This re-iteration does significantly decrease efficiency, and I imagine there must be a better way, but I
            // didn't feel like trying.
            if (co >= l) {
                oxy.removeIf(n -> ((n >> (LENGTH - 1) - finalI) & 1) == 0);
            } else {
                oxy.removeIf(n -> ((n >> (LENGTH - 1) - finalI) & 1) == 1);
            }
            i++;
        }

        // Repeat essentially the same process for the CO2 scrubber rating.
        i = 0;
        while (co2.size() > 1 && i < LENGTH) {
            int co = 0;
            for (int n : co2) {
                if (((n >> (LENGTH - 1) - i) & 1) == 1) co++;
            }
            final double l = (double) co2.size() / 2;
            final int finalI = i;
            // In this case, remove numbers that match the most common bit, defaulting to removing 1s in case of a tie.
            if (co < l) {
                co2.removeIf(n -> ((n >> (LENGTH - 1) - finalI) & 1) == 0);
            } else {
                co2.removeIf(n -> ((n >> (LENGTH - 1) - finalI) & 1) == 1);
            }
            i++;
        }

        // Life support rating = oxygen generator rating * co2 scrubber rating
        return String.valueOf((long) co2.get(0) * oxy.get(0));
    }
}
